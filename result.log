ft_memset:     [OK] [FAILED] [OK] [NO CRASH] [OK] [OK] [OK] 
[fail]: your memset return address is false/your memset does not work
Test code:
	const int size = 18;
	char b1[0xF00];

	memset(b1, 'B', 0xF00);
	char *r1 = memset(b1, 'A', size);
	char *r2 = ft_memset(b1, 'A', size);
	for (register int __i = 0; __i < size; ++__i)
	for (register int __i = 0; __i < size; ++__i)
	if (r1 != r2)
		exit(TEST_FAILED);
	r1 = memset("", 'A', (0));
	r2 = ft_memset("", 'A', 0);
	if (r1 != r2)
		exit(TEST_FAILED);
	exit(TEST_SUCCESS);

Diffs:
      memset: |\x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 |
   ft_memset: |\x42 \x42 \x42 \x42 \x42 \x42 \x42 \x42 \x42 \x42 \x42 \x42 \x42 \x42 \x42 \x42 \x42 \x42 |

[no crash]: your memset does not segfault when null parameter is sent !
Test code:
	ft_memset(((void*)0), 'a', 12);


ft_bzero:      [OK] [OK] [NO CRASH] [OK] 
[no crash]: your bzero does not segfault when null params is sent
Test code:
	ft_bzero(((void*)0), 0x12);


ft_memcpy:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [CRASH] 
[crash]: your memcpy does not behave well with NULL as both params with size
Test code:
	ft_memcpy(((void*)0), ((void*)0), 3);


ft_memmove:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [CRASH] [OK] 
[crash]: your memmove does not well with NULL as both parameters and size
Test code:
	ft_memmove(((void*)0), ((void*)0), 5);


ft_memchr:     [OK] [FAILED] [OK] [OK] [OK] [OK] [OK] [OK] 
[fail]: your memchr does not cast in unsigned the memory
Test code:
	char *src = "/|\x12\xff\x09\x42\2002\42|\\";
	int size = 10;

	if (memchr(src, '\200', size) == ft_memchr(src, '\200', size))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
      memchr: |€2"|\|
   ft_memchr: |(null)|

ft_memcmp:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strlen:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_isalpha:    [OK] 
ft_isdigit:    [OK] 
ft_isalnum:    [OK] 
ft_isascii:    [OK] 
ft_isprint:    [OK] 
ft_toupper:    [OK] 
ft_tolower:    [MISSING]
ft_strchr:     [OK] [OK] [OK] [OK] [OK] [OK] [FAILED] [OK] [OK] [NO CRASH] 
[fail]: your strchr does not work with \0
Test code:
	char *src = "there is so \0ma\0ny \0 \\0 in t\0his stri\0ng !\0\0\0\0";
	char *d1 = strchr(src, '\0');
	char *d2 = ft_strchr(src, '\0');

	if (d1 == d2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
      strchr: ||
   ft_strchr: |(null)|

[no crash]: your strchr does not segfault with NULL parameter
Test code:
	ft_strchr(((void*)0), '\0');


ft_strrchr:    [OK] [FAILED] [OK] [OK] [FAILED] [OK] [OK] [OK] 
[fail]: your strrchr does not work with basic input
Test code:
	char *src = "abbbbbbbb";
	char *d1 = strrchr(src, 'a');
	char *d2 = ft_strrchr(src, 'a');

	if (d1 == d2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strrchr: |abbbbbbbb|
  ft_strrchr: |(null)|

[fail]: your strrchr does not work with \0
Test code:
	char *src = "there is so \0ma\0ny \0 \\0 in t\0his stri\0ng !\0\0\0\0";
	char *d1 = strrchr(src, '\0');
	char *d2 = ft_strrchr(src, '\0');

	if (d1 == d2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strrchr: ||
  ft_strrchr: |(null)|

ft_strncmp:    [OK] [OK] [OK] [OK] [OK] [OK] [FAILED] [OK] [OK] [FAILED] [OK] [OK] [OK] [OK] 
[fail]: your strncmp does not cast in unsigned char the diff
Test code:
	char *s1 = "\200";
	char *s2 = "\0";
	int i1 = ((strncmp(s1, s2, 1) > 0) ? 1 : ((strncmp(s1, s2, 1) < 0) ? -1 : 0));
	int i2 = ((ft_strncmp(s1, s2, 1) > 0) ? 1 : ((ft_strncmp(s1, s2, 1) < 0) ? -1 : 0));

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strncmp: |1|
  ft_strncmp: |-1|

[fail]: your strncmp does not work with non ascii chars
Test code:
	char *s1 = "\x12\xff\x65\x12\xbd\xde\xad";
	char *s2 = "\x12\x02";
	size_t size = 6;
	int i1 = ((strncmp(s1, s2, size) > 0) ? 1 : ((strncmp(s1, s2, size) < 0) ? -1 : 0));
	int i2 = ((ft_strncmp(s1, s2, size) > 0) ? 1 : ((ft_strncmp(s1, s2, size) < 0) ? -1 : 0));

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strncmp: |1|
  ft_strncmp: |-1|

ft_strlcpy:    [OK] [FAILED] [OK] [FAILED] [FAILED] [FAILED] [OK] 
[fail]: your strlcpy does not return the good value
Test code:
	char *str = "the cake is a lie !\0I'm hidden lol\r\n";
	char buff1[0xF00];
	char buff2[0xF00];
	size_t r1;
	size_t r2;

	r1 = strlcpy(buff1, str, sizeof(buff1));
	r2 = ft_strlcpy(buff2, str, sizeof(buff2));
	if (r1 == r2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strlcpy: |19|
  ft_strlcpy: |3840|

[fail]: your strlcpy does works whe size < strlen(src)
Test code:
	char *str = "hello !";
	char buff1[0xF00];
	char buff2[0xF00];
	size_t r1;
	size_t r2;

	memset(buff1, 'A', 20);
	memset(buff2, 'A', 20);
	r1 = strlcpy(buff1, str, 2);
	r2 = ft_strlcpy(buff2, str, 2);
	if (r1 == r2 && !memcmp(buff1, buff2, 20))
		exit(TEST_SUCCESS);
	if (r1 != r2)
	{
	}
		for (register int __i = 0; __i < 20; ++__i)
		for (register int __i = 0; __i < 20; ++__i)
	}
	exit(TEST_FAILED);

Diffs:
     strlcpy: |7|
  ft_strlcpy: |2|

[fail]: your strlcpy does not works with 0-length string
Test code:
	char *str = "";
	char buff1[0xF00];
	char buff2[0xF00];
	size_t r1;
	size_t r2;

	memset(buff1, 'A', 20);
	memset(buff2, 'A', 20);
	r1 = strlcpy(buff1, str, sizeof(buff1));
	r2 = ft_strlcpy(buff2, str, sizeof(buff2));
	if (r1 == r2 && !memcmp(buff1, buff2, 20))
		exit(TEST_SUCCESS);
	if (r1 != r2)
	{
	}
		for (register int __i = 0; __i < 20; ++__i)
		for (register int __i = 0; __i < 20; ++__i)
	}
	exit(TEST_FAILED);

Diffs:
     strlcpy: |0|
  ft_strlcpy: |3840|

[fail]: your strlcpy copies while destsize is zero, or does not return the size of the string it tried to create
Test code:
	char *str = "BBBB";
	char buff1[0xF00];
	char buff2[0xF00];

	memset(buff1, 'A', 20);
	memset(buff2, 'A', 20);
	if (strlcpy(buff1, str, 0) != ft_strlcpy(buff2, str, 0))
		exit(TEST_FAILED);
	if (!memcmp(buff1, buff2, 20))
		exit(TEST_SUCCESS);
	for (register int __i = 0; __i < 20; ++__i)
	for (register int __i = 0; __i < 20; ++__i)
	exit(TEST_FAILED);

Diffs:


ft_strlcat:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [CRASH] 
[crash]: your strlcat crush when null parameter is sent with a size of 0
Test code:
	char b[0xF] = "nyan !";

	ft_strlcat(((void*)0), b, 0);
	exit(TEST_SUCCESS);


ft_strnstr:    [OK] [OK] [FAILED] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [CRASH] 
[fail]: your strnstr does not work with basic input
Test code:
	char *s1 = "MZIRIBMZIRIBMZE123";
	char *s2 = "MZIRIBMZE";
	size_t max = strlen(s2);
	char *i1 = strnstr(s1, s2, max);
	char *i2 = ft_strnstr(s1, s2, max);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strnstr: |(null)|
  ft_strnstr: |MZIRIBMZE123|

[crash]: your strnstr crush when null parameter is sent with a size of 0
Test code:
	ft_strnstr(((void*)0), "fake", 0);

	exit(TEST_SUCCESS);


ft_atoi:       [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_calloc:     [OK] [OK] [FAILED] [OK] [OK] 
[fail]: your calloc don't work with empty string
Test code:
	int size = 8539;

	void * d1 = ft_calloc(size, sizeof(int));
	void * d2 = calloc(size, sizeof(int));
	if (memcmp(d1, d2, size * sizeof(int)))
		exit(TEST_FAILED);
	free(d1);
	free(d2);
	exit(TEST_SUCCESS);

Diffs:


ft_strdup:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_substr:     [FAILED] [FAILED] [CRASH] [FAILED] [FAILED] [OK] [FAILED] [OK] {not protected}[FAILED] 
[fail]: your substr does not work with valid input
Test code:
	char *str = "i just want this part #############";
	size_t size = 22;
	char *ret = ft_substr(str, 0, size);

	if (!strncmp(ret, str, size))
	{
		free(ret);
		exit(TEST_SUCCESS);
	}
	free(ret);
	exit(TEST_FAILED);

Diffs:
      substr: |i just want this part|
   ft_substr: |i just want this part|

[fail]: your substr does not work with valid input
Test code:
	char *str = "i just want this part #############";
	size_t size = 20;
	char *ret = ft_substr(str, 5, size);

	if (!strncmp(ret, str + 5, size))
	{
		free(ret);
		exit(TEST_SUCCESS);
	}
	free(ret);
	exit(TEST_FAILED);

Diffs:
      substr: |t want this part ###|
   ft_substr: |t want this part ##|

[crash]: your substr does not work with empty strings
Test code:
	char *str = "";
	size_t size = 0;
	char *ret = ft_substr(str, 5, size);

	if (!strncmp(ret, str + 5, size))
	{
		free(ret);
		exit(TEST_SUCCESS);
	}
	free(ret);
	exit(TEST_FAILED);


[fail]: your substr did not allocate the good size so the \0 test may be false
Test code:
	char *str = "i just want this part #############";
	size_t size = 10;
	int ret_size;

	ft_substr(str, 5, size);
	ret_size = get_last_malloc_size();
	if ((int)size + 1 == ret_size)
	{
		exit(TEST_SUCCESS);
	}
	exit(TEST_FAILED);

Diffs:
      substr: |11|
   ft_substr: |10|

[fail]: your substr does not set \0 to the end of the string
Test code:
	char str[] = "i just want this part #############";
	size_t size = 20;

	char *ret = ft_substr(str, 5, size);
	str[size + 5] = 0;
	if (!memcmp(ret, str + 5, size + 1))
	{
		free(ret);
		exit(TEST_SUCCESS);
	}
	free(ret);
	exit(TEST_FAILED);

Diffs:
      substr: |t want this part ###|
   ft_substr: |t want this part ##|

[fail]: your substr does not work for a whole string
Test code:
	char *s = "all of this !";
	size_t size = strlen(s);
	char *ret = ft_substr(s, 0, size);

	if (!strcmp(s, ret))
	{
		free(ret);
		exit(TEST_SUCCESS);
	}
	free(ret);
	exit(TEST_FAILED);

Diffs:
      substr: |all of this !|
   ft_substr: |all of this |

[fail]: your substr does not work when start >= ft_strlen(s)
Test code:
	char *str = "01234";
	size_t size = 10;
	char *ret = ft_substr(str, 10, size);

	if (!strncmp(ret, "", 1))
	{
		free(ret);
		exit(TEST_SUCCESS);
	}
	free(ret);
	exit(TEST_FAILED);

Diffs:
      substr: ||
   ft_substr: | strjoin |

ft_strjoin:    [OK] [OK] [OK] [OK] [OK] {not protected}
ft_strtrim:    [MISSING]
ft_split:      [MISSING]
ft_itoa:       [FAILED] [FAILED] [FAILED] [FAILED] [FAILED] [OK] [KO] [OK] [OK] 
[fail]: your itoa does not work with basic input
Test code:
	char *i1 = ft_itoa(-623);
	char *i2 = ft_itoa(156);
	char *i3 = ft_itoa(-0);

	if (strcmp(i1, "-623"))
	{
		exit(TEST_FAILED);
	}
	if (strcmp(i2, "156"))
	{
		exit(TEST_FAILED);
	}
	if (strcmp("0", i3))
	{
		exit(TEST_FAILED);
	}
	exit(TEST_SUCCESS);

Diffs:
        itoa: |-623|
     ft_itoa: |½*.-|

[fail]: your itoa does not work with random number
Test code:
	srand(clock());
	int n;
	char *d;

	for (int i = 0; i < 2000; i++)
	{
		n = rand();
		d = ft_itoa(n);
		if (atoi(d) != n)
		{
			exit(TEST_FAILED);
		}
	}
	exit(TEST_SUCCESS);

Diffs:
        itoa: |164215730|
     ft_itoa: |0|

[fail]: your itoa does not work with max int
Test code:
	char *i1 = ft_itoa(2147483647);

	if (atoi(i1) != 2147483647)
	{
		exit(TEST_FAILED);
	}
	exit(TEST_SUCCESS);

Diffs:
        itoa: |2147483647|
     ft_itoa: |½2147483647|

[fail]: your itoa does not work with min int
Test code:
	char *i1 = ft_itoa((-2147483647 -1));

	if (atoi(i1) != (-2147483647 -1))
	{
		exit(TEST_FAILED);
	}
	exit(TEST_SUCCESS);

Diffs:
        itoa: |-2147483648|
     ft_itoa: |½./,),(-*,(|

[fail]: your itoa don't set \0 at the end of the string
Test code:

	char *i1 = ft_itoa(-1234);
	if (strcmp(i1, "-1234"))
	{
		exit(TEST_FAILED);
	}
	exit(TEST_SUCCESS);

Diffs:
        itoa: |-1234|
     ft_itoa: |A/.-,|

[KO]: your itoa does not allocate the good size so the \0 test may be false
Test code:
	int size;

	ft_itoa(-5859);
	size = get_last_malloc_size();
	if (size == 6)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
        itoa: |6|
     ft_itoa: |5|

ft_strmapi:    [MISSING]
ft_putchar_fd: [OK] [OK] 
ft_putstr_fd:  [OK] [OK] {not protected}
ft_putendl_fd: [FAILED] [FAILED] {not protected}
[fail]: your putendl_fd does not work with basic input
Test code:
	char buff1[0xF00] = "the cake is a lie !\0I'm hidden lol\r\n";
	char buff2[0xF00];

	fd_to_buffer(2);
	ft_putendl_fd(buff1, 2);
	write(1, "", 1);
	write(2, "", 1);
	get_fd_buffer(2, buff2, sizeof(buff2));
	strcat(buff1, "\n");
	if (!strcmp(buff1, buff2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
  putendl_fd: |the cake is a lie !
|
ft_putendl_fd: |the cake is a lie !|

[fail]: your putendl_fd does not work with non ascii chars
Test code:
	char buff1[0xF00] = "string \x01 of \x63 non \x0a ascii \x12 chars\x1d";
	char buff2[0xF00];

	fd_to_buffer(2);
	ft_putendl_fd(buff1, 2);
	write(1, "", 1);
	write(2, "", 1);
	get_fd_buffer(2, buff2, sizeof(buff2));
	strcat(buff1, "\n");
	if (!strcmp(buff1, buff2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
  putendl_fd: |string  of c non 
 ascii  chars
|
ft_putendl_fd: |string  of c non 
 ascii  chars|

ft_putnbr_fd:  [OK] [OK] [FAILED] [OK] [FAILED] 
[fail]: your putnbr_fd does not work with int min
Test code:
	int i = (-2147483647 -1);
	char buff[0xF0];

	fd_to_buffer(2);
	ft_putnbr_fd(i, 2);
	write(2, "", 1);
	get_fd_buffer(2, buff, 0xF0);
	if (atoi(buff) == i)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
   putnbr_fd: |-2147483648|
ft_putnbr_fd: |0|

[fail]: your putnbr_fd allocate memory, wtf ???
Test code:
	int i = (-2147483647 -1);
	char buff[0xF0];

	fd_to_buffer(2);
	ft_putnbr_fd(i, 2);
	write(2, "", 1);
	get_fd_buffer(2, buff, 0xF0);
	if (atoi(buff) == i)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
   putnbr_fd: |-2147483648|
ft_putnbr_fd: |0|

ft_lstnew:     [MISSING]
ft_lstadd_front: [MISSING]
ft_lstsize:    [MISSING]
ft_lstlast:    [MISSING]
ft_lstadd_back:[MISSING]
ft_lstdelone:  [MISSING]
ft_lstclear:   [MISSING]
ft_lstiter:    [MISSING]
ft_lstmap:     [MISSING]
